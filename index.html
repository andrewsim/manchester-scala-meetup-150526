<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Introduction to the Scala Type System</title>
    <meta name="description" content="Scala is a statically, strongly typed language with built in type inference. Its type system allows us to do some pretty interesting stuff like Ad-Hoc Polymorphism, defining recursive type, programming at the type level and so on. The things that we will cover in this talk include but not limited to some basic types in Scala, the concept of variance and bounds and also Ad-Hoc polymorphism.">
    <meta name="author" content="Andrew CS Sim">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/moon.css" id="theme">
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/obsidian.css">
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Type System in Scala</h1>
          <h3>The Short Introduction</h3>
          <p>
            <small>Created by <a href="http://hakim.se">Andrew C.S. Sim</a> / <a href="http://twitter.com/andrewcssim">@andrewcssim</a></small>
          </p>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Basics
              Types in Scala are __static__
              ```scala
              class Coffee
              class Tea

              val coffee: Coffee = new Coffee
              val tea: Coffee = new Tea
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Basics
              Types in Scala are __strong__
              ```scala
              class Coffee
              class Tea

              var coffee: Coffee = new Coffee
              coffee = new Tea
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Basics
              Types in Scala can be __inferred__
              ```scala
              class Coffee
              class Tea

              val coffee = new Coffee
              val tea = new Tea

              def describe(coffee: Coffee) = "Aromatic"
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Class
              ```scala
              class Coffee {
                def create(): Coffee
              }

              class Tea {
                def create(): Tea
              }
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Trait
              Similar to interfaces in Java.
              ```scala
              trait Beverage {
                def create(): Beverage
              }

              class Coffee extends Beverage {
                def create() = new Coffee
              }

              class Tea extends Beverage {
                def create() = new Tea
              }
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Type Parameters
              Allow us to write generic classes and traits.
              ```scala
              trait Beverage[A] {
                def create(): A
              }

              class Coffee extends Beverage[Coffee]

              class Tea extends Beverage[Tea]
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Abstract Type Members
              ```scala
              trait Beverage {
                type A
                def create(): A
              }

              class Coffee extends Beverage {
                type A = Coffee
              }

              class Tea extends Beverage {
                type A = Tea
              }
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Type Alias
              A trick to write more readable code. Instead of writing:
              ```scala
              val x: Map[String, Int]
              ```
              We can make it more readable by writing: 
              ```scala
              type Task = String
              type HoursSpent = Int

              val y: Map[Task, HoursSpent]
              ```
            </script>
          </section>
        </section>


        <section>
          <section data-markdown>
            <script type="text/template">
              ## Variance
              ```scala
              // 0, 1, 2, ...
              class NaturalNumber
              // ..., -2, -1, 0, 1, 2, ...
              class Integer extends NaturalNumber 

              trait Reader[NaturalNumber] {
                def read(): NaturalNumber
              }

              class NaturalNumberReader extends Reader[NaturalNumber]

              class IntegerReader extends Reader[Integer]
              ```

              ```scala
              val r_natural: NaturalNumberReader = new NaturalNumberReader {
                def read(): NaturalNumber = /// Implementation here
              }

              val r_integer: IntegerReader = new IntegerReader {
                def read(): Integer = /// Implementation here
              }
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## In-Variant
              By default, Type Parameter in Scala is ___In-Variant___.
              ```scala
              val r1: IntegerReader = r_integer

              val r2: NaturalNumberReader = r_natural

              val n: NaturalNumber = new Integer        // Valid
              val r3: NaturalNumberReader = r_integer   // Compilation error

              val r4: IntegerReader = r_natural         // Compilation error
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Co-Variant
              If ``Integer`` extends ``NaturalNumber``, then ``Reader[Integer]`` extends ``Reader[NaturalNumber]``.
              ```scala
              // 0, 1, 2, ...
              class NaturalNumber
              // ..., -2, -1, 0, 1, 2, ...
              class Integer extends NaturalNumber 

              trait Reader[+NaturalNumber] {
                def read(): NaturalNumber
              }

              class NaturalNumberReader extends Reader[NaturalNumber]
              class IntegerReader extends Reader[Integer]
              ```

              ```scala
              val r_integer: IntegerReader = new IntegerReader {
                def read(): Integer = /// Implementation here
              }

              val r: NaturalNumberReader = r_integer
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Contra-Variant
              If ``Integer`` is a subtype of ``NaturalNumber`` then ``Writer[NaturalNumber]`` is a subtype of ``Writer[Integer]``.
              ```scala
              // 0, 1, 2, ...
              class NaturalNumber
              // ..., -2, -1, 0, 1, 2, ...
              class Integer extends NaturalNumber 

              trait Writer[-NaturalNumber] {
                def write(): Unit
              }
              ```
            </script>
          </section>
        </section>


        <section>
          <section data-markdown>
            <script type="text/template">
              ## Ad-Hoc Polymorphism
              Assume the following are from third party library:
              ```scala
              class Coffee

              class Cake

              class Calories(val value: Double)
              ```
              <br>

              ```scala
              def consumeCoffee(coffee: Coffee) = new Calories(10.5)

              def consumeCake(cake: Cake) = new Calories(223.0)
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Ad-Hoc Polymorphism
              ```scala
              trait Consumable[A] {
                def hasCalories(consumable: A): Calories
              }

              object CoffeeConsumable extends Consumable[Coffee] {
                def hasCalories(consumable: Coffee) = new Calories(10.5)
              }

              object CakeConsumable extends Consumable[Cake] {
                def hasCalories(consumable: Cake) = new Calories(223.0)
              }
              ```
              <br>

              ```scala
              def consume[A](item: A)(consumable: Comsumable[A]) = 
                consumable.hasCalories(item)
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Ad-Hoc Polymorphism
              ```scala
              trait Consumable[A] {
                def hasCalories(consumable: A): Calories
              }

              implicit object CoffeeConsumable extends Consumable[Coffee] {
                def hasCalories(consumable: Coffee) = new Calories(10.5)
              }
              ```
              <br>

              ```scala
              def consume[A](item: A)(implicit consumable: Comsumable[A]) = 
                consumable.hasCalories(item)
              ```
            </script>
          </section>
        </section>


        <section>
          <section data-markdown>
            <script type="text/template">
              ## Recursive Type
              ```scala
              trait Beverage[A] {
                def create(): A
              }

              class Coffee extends Beverage[Coffee]

              class Tea extends Beverage[Tea]
              ```
              <br>
              ```scala
              class Water

              // valid
              class Coffee extends Beverage[Water]
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Recursive Type
              Constraints the subtypes to themselves using bounds.
              ```scala
              trait Beverage[A <: Beverage[A]] {
                def create(): A
              }

              class Coffee extends Beverage[Coffee]

              class Tea extends Beverage[Tea]
              ```
              <br>
              ```scala
              // compilation error
              class Coffee extends Beverage[Water]

              // valid
              class Tea extends Beverage[Coffee]
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Self Type
              ```scala
              trait Beverage[A <: Beverage[A]] { self: A =>
                def create(): A
              }

              class Coffee extends Beverage[Coffee]

              class Tea extends Beverage[Tea]
              ```
              Ensures that any class that extends ``Beverage`` is of type ``A``.

              <br>
              ```scala
              // compilation error
              class Tea extends Beverage[Coffee]
              ```
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Phantom Types

              ```scala
              sealed trait MachineStatus
              trait On extends MachineStatus
              trait Off extends MachineStatus

              class Machine[Status <: MachineStatus]

              def turnOnMachine(m:Machine[Off]) = new Machine[On]

              def turnOffMachine(m:Machine[On])= new Machine[Off]
              ```

              ```scala
              val machine = new Machine[Off]

              val on = turnOnMachine(machine)

              val off = turnOffMachine(on)

              turnOnMachine(on)     // Type Mismatch Error
              ```
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Structural Type
              Type safe duck typing.
              ```scala
              def quacker(duck: {def quack(value: String): String}) {
                println (duck.quack("Quack quack"))
              }
              ```

              ```scala
              object Duck {
                def quack(value: String) = value.toUpperCase
              }

              object NotADuck {
                def quack(value: String) = value.toLowerCase              }
              }

              quacker(Duck)       // QUACK QUACK
              quacker(NotADuck)   // quack quack
              ```
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Path Dependent Type
              Type-check on a type internal to another class.

              ```scala
              class Parent {
                class Child
              }

              class ChildrenContainer(p: Parent) {
                type ChildType = p.Child

                def add(c: ChildType) = // Implementation here
              }
              ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Type Projection
              Makes it possible for us to refer to the inner class without restricting it to a particular outer class instance.

              ```scala
              class Parent {
                class Child
              }

              class ChildrenContainer(p: Parent) {
                type ChildType = p.Child

                def add(c: ChildType) = // Implementation here
              }
              ```
            </script>
          </section>
        </section>

        <section>
          <h1>THE END</h1>
          <p style="text-align: left;">
            <a href="https://github.com/hakimel/reveal.js">Source code &amp; documentation</a>
          </p>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>
      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
    </script>
  </body>
</html>
